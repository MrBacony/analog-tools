# AnalogJS Library Structure Explanation - Reference Library

This document explains the file structure of an AnalogJS library using the `reference` library as an example. This structure is generated by the `@analog-tools/generator:library` generator and represents the standard approach for creating feature libraries with distributed file-based routing and API routes.

## Overall Structure

The reference library follows a well-organized structure that separates concerns between frontend components, backend API routes, and shared models. Here's the complete structure of the reference library:

```
libs/reference/
  ├── eslint.config.cjs           # ESLint configuration for the library
  ├── project.json                # Nx project configuration
  ├── README.md                   # Library documentation
  ├── tsconfig.json               # TypeScript configuration
  ├── tsconfig.lib.json           # TypeScript configuration for library compilation
  ├── tsconfig.spec.json          # TypeScript configuration for tests
  ├── vite.config.mts             # Vite configuration
  └── src/                        # Source code directory
      ├── index.ts                # Main entry point for frontend exports
      ├── test-setup.ts           # Test setup configuration
      ├── backend/                # Backend functionality
      │   ├── index.ts            # Backend-specific exports (for server-side imports)
      │   └── api/
      │       └── routes/         # API routes (following Nitro conventions)
      │           └── api/
      │               └── reference/  # Reference-specific API endpoints
      │                   └── hello.ts # Simple REST API endpoint
      ├── lib/                    # Library components
      │   ├── components/         # Reusable components
      │   │   └── .gitkeep
      │   ├── pages/              # Page components (used by route pages)
      │   │   └── reference.ts    # Main page component
      │   └── services/           # Business logic services
      │       └── .gitkeep
      ├── models/                 # Shared data models
      │   └── example-message.ts  # Type definitions with Zod schemas
      └── pages/                  # AnalogJS file-based routing pages
          └── reference/
              ├── (reference).page.ts # Parenthesized route (grouped route)
              └── reference.page.ts   # Standard page route
```

## Key Components Explained

### 1. Library Entry Points

The library has two separate entry points:

**Frontend Entry Point** (`src/index.ts`):
Exports components that can be imported by other applications or libraries in the frontend:

```typescript
// src/index.ts
export * from './lib/pages/reference';
```

**Backend Entry Point** (`src/backend/index.ts`):
Used for server-side imports when needed. This separation allows for better tree-shaking and ensures backend code isn't bundled in the client:

```typescript
// src/backend/index.ts
// Backend exports for reference library
// This file is used for server-side imports

// Export API route handlers if needed
```

### 2. Models Structure

Shared data models live in the `src/models/` directory and use Zod for runtime validation:

```typescript
// src/models/example-message.ts
import { z } from 'zod';

export const ExampleMessageSchema = z.object({
  message: z.string(),
});

export type ExampleMessage = z.infer<typeof ExampleMessageSchema>;
```

This ensures type consistency across frontend and backend with runtime validation.

### 3. API Structure

REST API endpoints are located under `src/backend/api/routes/api/reference/`:

```typescript
// src/backend/api/routes/api/reference/hello.ts
import { defineEventHandler } from 'h3';
import type { ExampleMessage } from '../../../models/example-message';

export default defineEventHandler(
  (): ExampleMessage => ({ message: 'Hello World' })
);
```

This follows the file-based routing convention used by Nitro (the server powering AnalogJS), where the file path corresponds to the API endpoint path. The above file creates the endpoint `/api/reference/hello`.

### 4. Component Structure

The library separates concerns between reusable components and page-specific components:

**Page Components** (`src/lib/pages/`):
These are the actual UI components that contain the logic and templates:

```typescript
// src/lib/pages/reference.ts
import { Component, resource, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { lastValueFrom } from 'rxjs';
import type { ExampleMessage } from '../../models/example-message';

@Component({
  selector: 'lib-reference',
  standalone: true,
  template: `
    <div class="flex flex-col gap-4">
      <h1>Reference</h1>
      <p>This is an Example Page</p>

      @if (data.value(); as result) {
      <div class="item">
        <p>{{ result.message }}</p>
      </div>
      }
    </div>
  `,
})
export class ReferenceComponent {
  private http = inject(HttpClient);

  public data = resource({
    loader: () =>
      lastValueFrom(this.http.get<ExampleMessage>('/api/reference/hello')),
  });
}
```

**Reusable Components** (`src/lib/components/`):
Place shared, reusable components here that can be used across multiple pages.

**Services** (`src/lib/services/`):
Business logic and data access services.

### 5. File-Based Routing Pages

AnalogJS uses file-based routing similar to Next.js. The actual route pages are thin wrappers that import and render page components:

**Standard Page** (`src/pages/reference/reference.page.ts`):
- Exposed as `/reference/reference` route when the library is included in an app
- Default export is required for AnalogJS routing

```typescript
import { Component } from '@angular/core';
import { ReferenceComponent } from '../../lib/pages/reference';

@Component({
  selector: 'lib-reference-page',
  standalone: true,
  imports: [ReferenceComponent],
  template: `<lib-reference />`,
})
export default class ReferencePageComponent {}
```

**Grouped Route** (`src/pages/reference/(reference).page.ts`):
- Exposed as `/reference` route when the library is included in an app
- The parentheses indicate a group route in the AnalogJS routing system
- Useful for layout grouping or route organization

```typescript
import { Component } from '@angular/core';
import { ReferenceComponent } from '../../lib/pages/reference';

@Component({
  selector: 'lib-reference-index-page',
  standalone: true,
  imports: [ReferenceComponent],
  template: `<lib-reference />`,
})
export default class ReferenceIndexPageComponent {}
```

## Integration with Main Application

The reference library is integrated with the main application through several configuration points:

### 1. TypeScript Path Mapping

In the root `tsconfig.base.json`, add path mappings for both frontend and backend exports:

```json
{
  "compilerOptions": {
    "paths": {
      "@analog-tools/reference": ["libs/reference/src/index.ts"],
      "@analog-tools/reference/backend": ["libs/reference/src/backend/index.ts"]
    }
  }
}
```

The dual exports allow:
- Frontend code to import from `@analog-tools/reference`
- Backend/server code to import from `@analog-tools/reference/backend`
- Better tree-shaking and separation of concerns

### 2. Vite Configuration

In the app's `vite.config.ts`, configure the AnalogJS plugin to include the library's pages and API routes:

```typescript
import analog from '@analogjs/platform';
import { defineConfig } from 'vite';

export default defineConfig(({ mode }) => {
  return {
    plugins: [
      analog({
        liveReload: true,
        additionalPagesDirs: [
          '/libs/reference/src/pages',  // Add library pages
        ],
        additionalAPIDirs: [
          '/libs/reference/src/backend/api',  // Add library API routes
        ],
      }),
    ],
  };
});
```

> **Critical**: You must configure the Vite configuration file for **each library** you want to integrate with your main application. For every library, you need to add its pages and API routes directories to the respective arrays (`additionalPagesDirs` and `additionalAPIDirs`). 
>
> Without this configuration:
> - The library's pages won't be accessible through the application's routing system
> - The library's API routes won't be served by the application's server
> - Live reload won't work for changes in the library

### 3. Styling Integration (Tailwind v4)

For Tailwind CSS v4 (using `@tailwindcss/vite`), configure the `styles.css` to scan library files:

```css
@import 'tailwindcss' source(none);
@source '../../../{apps,libs}/**/*.{html,css,js,ts,jsx,tsx}';
```

This ensures Tailwind scans all library files for class usage, including the classes used in:
- Component templates
- Page components
- Any TypeScript files with inline templates

### 4. Server-Side Dependencies

If your library uses dependencies that need to be available server-side (like authentication libraries, database clients, etc.), add them to the `ssr.noExternal` array:

```typescript
export default defineConfig(({ mode }) => {
  return {
    ssr: {
      noExternal: [
        '@analog-tools/reference',
        // Add other dependencies as needed
      ],
    },
    // ...rest of config
  };
});
```

This integration allows:
- The application to import components from the library using the TypeScript path alias
- The library's pages to be part of the application's routing
- The library's API routes to be served by the application's server
- Hot module replacement (HMR) to work across the monorepo
- Tailwind to generate styles for library components

## Development Workflow

When developing features for a library:

1. **Define Models** in `models/`:
   - Create TypeScript types with Zod schemas for runtime validation
   - Export both the schema and the inferred type
   - These models can be shared between frontend and backend

2. **Create API Endpoints** in `backend/api/routes/api/<library-name>/`:
   - Use `defineEventHandler` from h3
   - Import and use the models for type safety
   - File path determines the API route URL

3. **Build Page Components** in `lib/pages/`:
   - Create standalone Angular components with modern patterns (signals, resources)
   - Use `resource()` for data fetching with automatic loading states
   - Import models for type safety
   - Use Tailwind CSS classes for styling

4. **Create Route Pages** in `pages/<library-name>/`:
   - Import and render page components
   - Keep route pages thin - logic belongs in page components
   - Use parenthesized routes for index/grouped routes

5. **Export Public API** in `index.ts`:
   - Export components that should be available to other libraries/apps
   - Keep the exports minimal - only what's needed externally

6. **Export Backend API** (if needed) in `backend/index.ts`:
   - Export server-side functionality that other parts of the app need
   - Separate from frontend exports for better tree-shaking

### File Organization Best Practices

- **Components vs Pages**: 
  - `lib/components/`: Reusable UI components (buttons, cards, forms)
  - `lib/pages/`: Page-specific components with business logic
  - `pages/`: Thin route wrappers (default exports for AnalogJS)

- **Models**: 
  - Always use Zod schemas for runtime validation
  - Place in `models/` directory for shared access
  - Export both schema and type

- **Services**:
  - Business logic and data access layers
  - Injectable services with `providedIn: 'root'`
  - Keep API calls separated from components when logic is complex

- **API Routes**:
  - Follow the Nitro convention: `backend/api/routes/api/<library-name>/`
  - Use TypeScript for type safety
  - Return typed responses using imported models

### Generator Command

To create a new library with this structure:

```bash
npx nx generate @analog-tools/generator:library --name=<library-name> --project=<app-name> --pages=true --api=true
```

Options:
- `--name`: The library name (kebab-case)
- `--project`: The app that will consume this library
- `--pages`: Generate pages directory structure (default: false)
- `--api`: Generate API routes directory structure (default: false)
- `--no-interactive`: Skip prompts and use defaults

The generator will:
1. Create the library structure
2. Update `tsconfig.base.json` with path mappings
3. Update the app's `vite.config.ts` with library paths
4. Set up example files to get you started
5. Update Tailwind configuration if applicable
